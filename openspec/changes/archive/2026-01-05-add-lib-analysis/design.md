## Context

`print_exe_deps.py` 当前使用 `pefile` 库解析 PE 文件格式。静态库（.lib）使用 COFF 归档格式，需要不同的解析方法。

**约束条件：**
- 保持与现有 PE 分析功能的一致性
- 复用现有的 HTML 报告框架
- 支持递归依赖分析
- 最小化新增依赖

## Goals / Non-Goals

**Goals:**
- 支持分析 Windows 静态库（.lib）文件
- 识别导入库和静态库两种类型
- 提取静态库引用的外部符号和依赖库
- 递归分析依赖的子 .lib 文件
- 生成与 PE 分析一致的 HTML 报告

**Non-Goals:**
- 不支持 Linux/macOS 的静态库格式（.a）
- 不分析源代码级别的依赖
- 不提供符号级别的详细分析

## Decisions

### 1. .lib 文件类型识别

**决定：** 通过解析 .lib 文件头部和成员来区分导入库和静态库

**识别方法：**
- **导入库**：包含 `.idata` 节或导入描述符，成员通常很小
- **静态库**：包含完整的 .obj 文件，有 `.text`、`.data` 等节

### 2. 解析方案选择

**决定：** 使用 Python 内置能力 + dumpbin 工具辅助

**方案：**
1. 优先使用 `dumpbin.exe`（VS 开发工具）解析依赖信息
2. 如果 dumpbin 不可用，使用纯 Python 解析 COFF 归档格式
3. 对于导入库，直接提取关联的 DLL 名称

**替代方案：**
- 使用第三方库如 `pycoff` → 依赖不稳定，维护较少
- 仅使用 dumpbin → 需要安装 VS，限制使用场景

### 3. 依赖信息提取

**决定：** 从 .lib 文件中提取以下依赖信息

**导入库：**
- 关联的 DLL 名称
- 导出符号列表（可选）

**静态库：**
- 引用的外部符号（未定义符号）
- 通过符号名称推断依赖的 .lib 文件
- 包含的 .obj 文件列表

### 4. 依赖库搜索路径

**决定：** 使用以下搜索顺序查找依赖的 .lib 文件

1. 与被分析 .lib 同目录
2. 用户指定的搜索路径（新增 `-L` 参数）
3. 系统库目录（Windows SDK、VC 运行时）

### 5. HTML 报告集成

**决定：** 复用现有 HTML 报告框架，扩展节点类型

**新增节点类型：**
- `lib-import`：导入库
- `lib-static`：静态库
- `symbol`：外部符号（可选显示）

**图标设计：**
- `L`：静态库节点
- `I`：导入库节点
- 复用现有 `+`/`-`/`·` 表示展开状态

## Risks / Trade-offs

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| dumpbin 不可用 | 功能受限 | 提供纯 Python 备选解析方案 |
| 符号名称混淆 | 依赖推断不准确 | 提供手动指定依赖库的选项 |
| 大型静态库解析慢 | 用户体验差 | 添加进度提示，支持跳过符号分析 |
| 循环依赖 | 无限递归 | 复用现有循环检测机制 |

## Open Questions

1. 是否需要支持 `.lib` 文件的批量分析？
2. 符号级别的详细信息是否需要在报告中展示？

